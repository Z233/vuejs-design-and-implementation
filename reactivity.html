<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Reactivity</title>
  </head>
  <body></body>
  <script>
    // 存储副作用函数的桶
    const bucket = new WeakMap()

    // 原始数据
    const data = {
      foo: 0,
      bar: 1,
    }

    // 对原始数据的代理

    const ITERATE_KEY = Symbol()

    function createReactive(obj, isShallow = false) {
      return new Proxy(obj, {
        // 拦截读取操作
        get(target, key, receiver) {
          if (key === 'raw') {
            return target
          }

          track(target, key)

          const res = Reflect.get(target, key, receiver)

          if (isShallow) {
            return res
          }

          if (typeof res === 'object' && res !== null) {
            return reactive(res)
          }

          return res
        },
        // 拦截设置操作
        set(target, key, newVal, receiver) {
          const oldVal = target[key]

          const type = Object.prototype.hasOwnProperty.call(
            target,
            key
          )
            ? TriggerType.SET
            : TriggerType.ADD
          const res = Reflect.set(target, key, newVal, receiver)

          if (target === receiver.raw) {
            if (
              newVal !== oldVal &&
              (newVal === newVal || oldVal === oldVal)
            ) {
              trigger(target, key, type)
            }
          }

          return res
        },

        has(target, key) {
          track(target, key)
          return Reflect.has(target, key)
        },

        ownKeys(target) {
          track(target, ITERATE_KEY)
          return Reflect.ownKeys(target)
        },

        deleteProperty(target, key) {
          const hadKey = Object.prototype.hasOwnProperty.call(
            target,
            key
          )
          const res = Reflect.deleteProperty(target, key)

          // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
          if (hadKey && res) trigger(target, key, TriggerType.DELETE)

          return res
        },
      })
    }

    function reactive(obj) {
      return createReactive(obj)
    }

    function shallowReactive(obj) {
      return createReactive(obj, true)
    }

    function track(target, key) {
      if (!activeEffect) return

      let depsMap = bucket.get(target)
      if (!depsMap) {
        bucket.set(target, (depsMap = new Map()))
      }

      let deps = depsMap.get(key)
      if (!deps) {
        depsMap.set(key, (deps = new Set()))
      }

      deps.add(activeEffect)

      activeEffect.deps.push(deps)
    }

    const TriggerType = {
      SET: 'SET',
      ADD: 'ADD',
      DELETE: 'DELETE',
    }

    function trigger(target, key, type) {
      const depsMap = bucket.get(target)
      if (!depsMap) return
      const effects = depsMap.get(key)

      const effectsToRun = new Set()
      effects &&
        effects.forEach((effect) => {
          if (effect !== activeEffect) {
            effectsToRun.add(effect)
          }
        })

      if (type === TriggerType.ADD || type === TriggerType.DELETE) {
        const iterateEffects = depsMap.get(ITERATE_KEY)
        iterateEffects &&
          iterateEffects.forEach((effect) => {
            if (effect !== activeEffect) {
              effectsToRun.add(effect)
            }
          })
      }

      effectsToRun.forEach((effectFn) => {
        if (effectFn.options.scheduler) {
          effectFn.options.scheduler(effectFn)
        } else {
          effectFn()
        }
      })
    }

    // 用一个全局变量存储当前激活的 effect 函数
    let activeEffect
    const effectStack = []

    function effect(fn, options = {}) {
      const effectFn = () => {
        cleanup(effectFn)

        activeEffect = effectFn
        effectStack.push(activeEffect)

        const res = fn()

        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]

        return res
      }

      effectFn.options = options
      effectFn.deps = []

      if (!options.lazy) {
        effectFn()
      }

      return effectFn
    }

    function cleanup(effectFn) {
      effectFn.deps.forEach((deps) => deps.delete(effectFn))
      effectFn.length = 0
    }

    // Set 的特性可以帮助去重
    const jobQueue = new Set()
    // 创建一个 Promise 实例，用来存储微任务
    const jobPromise = Promise.resolve()

    let isFlushing = false
    function flushJob() {
      if (isFlushing) return
      isFlushing = true

      jobPromise
        .then(() => {
          jobQueue.forEach((job) => job())
        })
        .finally(() => {
          isFlushing = false
        })
    }

    // ============ Methods ============

    function computed(getter) {
      let value
      let dirty = true

      const effectFn = effect(getter, {
        lazy: true,
        scheduler: () => {
          if (!dirty) {
            dirty = true
            trigger(obj, 'value')
          }
        },
      })

      const obj = {
        get value() {
          if (dirty) {
            value = effectFn()
            dirty = false
          }

          track(obj, 'value')
          return value
        },
      }

      return obj
    }

    function watch(source, callback, options = {}) {
      let getter
      if (typeof source === 'function') {
        getter = source
      } else {
        getter = () => traverse(source)
      }

      let oldValue, newValue

      // cleanup 用来存储用户注册的过期回调
      let cleanup
      function onInvalidate(fn) {
        cleanup = fn
      }

      const job = () => {
        // 在 scheduler 中重新执行副作用函数，得到的是新值
        newValue = effectFn()

        // 如果用户注册了过期回调，执行过期回调
        if (cleanup) cleanup()
        // 将 onInvalidate 传递给用户调用
        callback(newValue, oldValue, onInvalidate)

        // 更新旧值，不然下一次会得到错误的旧值
        oldValue = newValue
      }

      const effectFn = effect(() => getter(), {
        lazy: true,
        scheduler: () => {
          if (options.flush === 'post') {
            const p = Promise.resolve()
            p.then(job)
          } else {
            job()
          }
        },
      })

      if (options.immediate) {
        job()
      } else {
        oldValue = effectFn()
      }
    }

    function traverse(value, seen = new Set()) {
      if (
        typeof value !== 'object' ||
        value === null ||
        seen.has(value)
      )
        return

      seen.add(value)

      for (const key in value) {
        traverse(value[key], seen)
      }

      return value
    }

    // ============ Testing ============

    const obj = shallowReactive({ foo: { bar: 1 } })

    effect(() => {
      console.log('----------------------')
      console.log(obj.foo.bar)
    })

    obj.foo = { bar: 2 }

    obj.foo.bar = 3
  </script>
</html>
