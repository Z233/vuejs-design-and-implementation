<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Reactivity</title>
  </head>
  <body></body>
  <script>
    // 存储副作用函数的桶
    const bucket = new WeakMap()

    // 原始数据
    const data = { foo: 1, bar: 2 }

    // 对原始数据的代理
    const obj = new Proxy(data, {
      // 拦截读取操作
      get(target, key) {
        // 没有 activeEffect，直接返回属性值
        if (!activeEffect) return target[key]

        track(target, key)

        return target[key]
      },
      // 拦截设置操作
      set(target, key, newVal) {
        // 设置属性值
        target[key] = newVal

        // 取出所有 effectFn 并执行
        trigger(target, key)
      },
    })

    window.obj = obj

    function track(target, key) {
      if (!activeEffect) return

      let depsMap = bucket.get(target)
      if (!depsMap) {
        bucket.set(target, (depsMap = new Map()))
      }

      let deps = depsMap.get(key)
      if (!deps) {
        depsMap.set(key, (deps = new Set()))
      }

      deps.add(activeEffect)

      activeEffect.deps.push(deps)
    }

    function trigger(target, key) {
      const depsMap = bucket.get(target)
      if (!depsMap) return
      const effects = depsMap.get(key)

      const effectsToRun = new Set()
      effect &&
        effects.forEach((effect) => {
          if (effect !== activeEffect) {
            effectsToRun.add(effect)
          }
        })

      effectsToRun.forEach((effectFn) => {
        if (effectFn.options.scheduler) {
          effectFn.options.scheduler(effectFn)
        } else {
          effectFn()
        }
      })
    }

    // 用一个全局变量存储当前激活的 effect 函数
    let activeEffect
    const effectStack = []

    function effect(fn, options = {}) {
      const effectFn = () => {
        cleanup(effectFn)

        activeEffect = effectFn
        effectStack.push(activeEffect)

        const res = fn()

        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]

        return res
      }

      effectFn.options = options
      effectFn.deps = []

      if (!options.lazy) {
        effectFn()
      }

      return effectFn
    }

    function cleanup(effectFn) {
      effectFn.deps.forEach((deps) => deps.delete(effectFn))
      effectFn.length = 0
    }

    // Set 的特性可以帮助去重
    const jobQueue = new Set()
    // 创建一个 Promise 实例，用来存储微任务
    const jobPromise = Promise.resolve()

    let isFlushing = false
    function flushJob() {
      if (isFlushing) return
      isFlushing = true

      jobPromise
        .then(() => {
          jobQueue.forEach((job) => job())
        })
        .finally(() => {
          isFlushing = false
        })
    }

    // ============ Methods ============

    function computed(getter) {
      let value
      let dirty = true

      const effectFn = effect(getter, {
        lazy: true,
        scheduler: () => {
          if (!dirty) {
            dirty = true
            trigger(obj, 'value')
          }
        },
      })

      const obj = {
        get value() {
          if (dirty) {
            value = effectFn()
            dirty = false
          }

          track(obj, 'value')
          return value
        },
      }

      return obj
    }

    function watch(source, callback, options = {}) {
      let getter
      if (typeof source === 'function') {
        getter = source
      } else {
        getter = () => traverse(source)
      }

      let oldValue, newValue

      const job = () => {
        // 在 scheduler 中重新执行副作用函数，得到的是新值
        newValue = effectFn()
        callback(newValue, oldValue)
        // 更新旧值，不然下一次会得到错误的旧值
        oldValue = newValue
      }

      const effectFn = effect(() => getter(), {
        lazy: true,
        scheduler: () => {
          if (options.flush === 'post') {
            const p = Promise.resolve()
            p.then(job)
          } else {
            job()
          }
        },
      })

      if (options.immediate) {
        job()
      } else {
        oldValue = effectFn()
      }
    }

    function traverse(value, seen = new Set()) {
      if (
        typeof value !== 'object' ||
        value === null ||
        seen.has(value)
      )
        return

      seen.add(value)

      for (const key in value) {
        traverse(value[key], seen)
      }

      return value
    }

    // ============ Testing ============

    watch(
      () => obj.foo,
      (newVal, oldVal) => {
        console.log('数据变化了', {
          newVal,
          oldVal,
        })
      },
      {
        flush: 'post', // 'pre' | 'post' | 'sync'
      }
    )

    setTimeout(() => {
      obj.foo++
    }, 1000)
  </script>
</html>
